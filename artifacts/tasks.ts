/**
 * Tasks Artifact Generator - SpecFirst 3.0
 * 
 * Generates tasks.md artifacts in ISC (Ideal State Criteria) format.
 * Native ISC generation - no conversion layer (ADR-005).
 * 
 * @module artifacts/tasks
 * @version 3.0.0
 */

import type { TasksArtifact, ISCCriterion, AntiCriterion } from "./types";

/**
 * Generates YAML frontmatter for tasks artifact.
 */
function generateFrontmatter(featureName: string): string {
  const now = new Date().toISOString().split("T")[0];
  
  return `---
feature: ${featureName}
phase: implement
status: pending
created: ${now}
based_on: plan.md
---`;
}

/**
 * Validates that a criterion is exactly 8 words.
 * 
 * @param criterion - The criterion text
 * @returns Object with valid flag and word count
 */
export function validateCriterionWordCount(criterion: string): { valid: boolean; wordCount: number } {
  const words = criterion.trim().split(/\s+/).filter(w => w.length > 0);
  return {
    valid: words.length === 8,
    wordCount: words.length,
  };
}

/**
 * Generates the ISC criteria table.
 */
function generateCriteriaTable(criteria: ISCCriterion[], phaseGrouped: boolean = true): string {
  if (criteria.length === 0) {
    return "| # | Criterion (exactly 8 words) | Status | Evidence |\n|---|----------------------------|--------|----------|\n| - | No criteria defined | - | - |";
  }
  
  // Group by phase if phase information is available
  if (phaseGrouped && criteria.some(c => c.phase)) {
    const phases = [...new Set(criteria.map(c => c.phase).filter(Boolean))];
    
    return phases.map(phase => {
      const phaseCriteria = criteria.filter(c => c.phase === phase);
      const header = `### ${phase}\n\n| # | Criterion (exactly 8 words) | Status | Evidence |\n|---|----------------------------|--------|----------|`;
      const rows = phaseCriteria
        .map(c => `| ${c.id} | ${c.criterion} | ${c.status} | ${c.evidence || "-"} |`)
        .join("\n");
      return `${header}\n${rows}`;
    }).join("\n\n");
  }
  
  // Flat table
  const header = "| # | Criterion (exactly 8 words) | Status | Evidence |\n|---|----------------------------|--------|----------|";
  const rows = criteria
    .map(c => `| ${c.id} | ${c.criterion} | ${c.status} | ${c.evidence || "-"} |`)
    .join("\n");
  
  return `${header}\n${rows}`;
}

/**
 * Generates the anti-criteria table.
 */
function generateAntiCriteriaTable(antiCriteria: AntiCriterion[]): string {
  if (antiCriteria.length === 0) {
    return "| # | Anti-Criterion | Status |\n|---|---------------|--------|\n| - | No anti-criteria defined | - |";
  }
  
  const header = "| # | Anti-Criterion | Status |\n|---|---------------|--------|";
  const rows = antiCriteria
    .map(c => `| ${c.id} | ${c.criterion} | ${c.status} |`)
    .join("\n");
  
  return `${header}\n${rows}`;
}

/**
 * Generates the progress section.
 */
function generateProgress(criteria: ISCCriterion[]): string {
  const completed = criteria.filter(c => c.status === "âœ…").length;
  const total = criteria.length;
  
  let status = "PENDING";
  if (completed === total && total > 0) {
    status = "COMPLETE";
  } else if (completed > 0) {
    status = "IN_PROGRESS";
  }
  
  return `**Completed:** ${completed}/${total} verified
**Status:** ${status}`;
}

/**
 * Generates a complete tasks.md artifact in ISC format.
 */
export function generateTasks(
  featureName: string,
  ideal: string,
  criteria: ISCCriterion[],
  antiCriteria: AntiCriterion[],
  parallelizationOpportunities?: string[],
  implementationNotes?: string
): string {
  const frontmatter = generateFrontmatter(featureName);
  const criteriaTable = generateCriteriaTable(criteria);
  const antiTable = generateAntiCriteriaTable(antiCriteria);
  const progress = generateProgress(criteria);
  
  let parallelSection = "";
  if (parallelizationOpportunities && parallelizationOpportunities.length > 0) {
    const items = parallelizationOpportunities.map(p => `- [P] ${p}`).join("\n");
    parallelSection = `\n\n## Parallelization Opportunities\n\n${items}`;
  }
  
  let notesSection = "";
  if (implementationNotes) {
    notesSection = `\n\n## Implementation Notes\n\n${implementationNotes}`;
  }
  
  return `${frontmatter}

# ${featureName} - Implementation Tasks

## IDEAL

${ideal}

---

## ISC TRACKER

${criteriaTable}

---

## ANTI-CRITERIA

${antiTable}

---

## PROGRESS

${progress}${parallelSection}${notesSection}

---

*Generated by SpecFirst 3.0*
`;
}

/**
 * Creates a minimal tasks template for user to fill in.
 */
export function createTasksTemplate(featureName: string): string {
  const frontmatter = generateFrontmatter(featureName);
  
  return `${frontmatter}

# ${featureName} - Implementation Tasks

## IDEAL

[1-2 sentence description of the ideal outcome when all criteria are verified]

---

## ISC TRACKER

| # | Criterion (exactly 8 words) | Status | Evidence |
|---|----------------------------|--------|----------|
| 1 | [Testable state condition in 8 words] | â¬œ | - |
| 2 | [Testable state condition in 8 words] | â¬œ | - |
| 3 | [Testable state condition in 8 words] | â¬œ | - |

---

## ANTI-CRITERIA

| # | Anti-Criterion | Status |
|---|---------------|--------|
| A1 | [Failure mode to avoid] | ðŸ‘€ |
| A2 | [Another failure mode] | ðŸ‘€ |

---

## PROGRESS

**Completed:** 0/3 verified
**Status:** PENDING

---

*Generated by SpecFirst 3.0*
`;
}

/**
 * Validates a tasks artifact structure and ISC format.
 */
export function validateTasks(content: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check for frontmatter
  if (!content.startsWith("---")) {
    errors.push("Missing YAML frontmatter");
  }
  
  // Check for required sections
  const requiredSections = [
    "IDEAL",
    "ISC TRACKER",
    "ANTI-CRITERIA",
    "PROGRESS",
  ];
  
  for (const section of requiredSections) {
    if (!content.includes(`## ${section}`)) {
      errors.push(`Missing required section: ${section}`);
    }
  }
  
  // Validate ISC criteria format (8 words)
  const lines = content.split("\n");
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check table rows (lines starting with |)
    if (line.match(/^\|\s*\d+\s*\|/)) {
      // Extract criterion text (second column)
      const columns = line.split("|").filter(c => c.trim());
      if (columns.length >= 2) {
        const criterion = columns[1].trim();
        
        // Skip header rows
        if (criterion.includes("Criterion") || criterion === "-") {
          continue;
        }
        
        const validation = validateCriterionWordCount(criterion);
        if (!validation.valid) {
          errors.push(`Line ${i + 1}: Criterion has ${validation.wordCount} words (expected 8): "${criterion}"`);
        }
      }
    }
  }
  
  // Check for valid status symbols
  const validSymbols = ["â¬œ", "ðŸ”„", "âœ…", "âŒ", "ðŸ‘€"];
  const symbolPattern = /\|\s*([â¬œðŸ”„âœ…âŒðŸ‘€])\s*\|/g;
  let match;
  while ((match = symbolPattern.exec(content)) !== null) {
    if (!validSymbols.includes(match[1])) {
      errors.push(`Invalid status symbol found: "${match[1]}"`);
    }
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Parses a tasks.md file into structured ISCCriterion objects.
 */
export function parseTasksFile(content: string): { criteria: ISCCriterion[]; antiCriteria: AntiCriterion[] } {
  const criteria: ISCCriterion[] = [];
  const antiCriteria: AntiCriterion[] = [];
  
  const lines = content.split("\n");
  let inISCSection = false;
  let inAntiSection = false;
  
  for (const line of lines) {
    if (line.includes("## ISC TRACKER")) {
      inISCSection = true;
      inAntiSection = false;
      continue;
    }
    
    if (line.includes("## ANTI-CRITERIA")) {
      inISCSection = false;
      inAntiSection = true;
      continue;
    }
    
    if (line.includes("## PROGRESS") || line.includes("## Parallelization")) {
      inISCSection = false;
      inAntiSection = false;
      continue;
    }
    
    // Parse ISC criteria rows
    if (inISCSection && line.match(/^\|\s*\d+\s*\|/)) {
      const columns = line.split("|").filter(c => c.trim());
      if (columns.length >= 3) {
        const id = parseInt(columns[0].trim(), 10);
        const criterion = columns[1].trim();
        const status = columns[2].trim() as ISCCriterion["status"];
        const evidence = columns[3]?.trim() || undefined;
        
        criteria.push({ id, criterion, status, evidence });
      }
    }
    
    // Parse anti-criteria rows
    if (inAntiSection && line.match(/^\|\s*A\d+\s*\|/)) {
      const columns = line.split("|").filter(c => c.trim());
      if (columns.length >= 2) {
        const id = columns[0].trim();
        const criterion = columns[1].trim();
        const status = columns[2]?.trim() as AntiCriterion["status"] || "ðŸ‘€";
        
        antiCriteria.push({ id, criterion, status });
      }
    }
  }
  
  return { criteria, antiCriteria };
}

// Export for testing
export const __testing = {
  generateFrontmatter,
  generateCriteriaTable,
  generateAntiCriteriaTable,
  generateProgress,
  validateCriterionWordCount,
};
